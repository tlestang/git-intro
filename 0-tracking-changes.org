#+PROPERTY: header-args :dir 0-tracking-changes
#+LATEX_HEADER: \usepackage{geometry}[bottom=2cm, top=2cm, left=2cm, right=2cm]
#+OPTIONS: author:nil date:nil toc:nil

#+TITLE:Tracking changes
#+INCLUDE: init.inc
#+CALL: init()

* Initializing the repository

A /repository/ refers to a directory containing a database of
versions. With Git, the database of versions -- along with various
other settings -- is contained in a hidden =.git/= directory inside a
repository.

We start with a directory =0-tracking-changes= that contains a Python
script =plot_data.py= as well as some data file =example_data.csv=.

#+begin_src python :tangle 0-tracking-changes/plot_data.py :exports code
  import numpy

  data = numpy.loadtxt("example_data.csv", delimiter=",")
#+end_src

#+RESULTS:

#+begin_src yaml :tangle 0-tracking-changes/example_data.csv :exports code
  -2,0.699369
  -1.64,0.700462
  -1.33,0.695354
  -0.7,1.03905
  0,1.97389
  0.45,2.41143
  1.2,1.91091
  1.64,0.919576
  2.32,-0.730975
  2.9,-1.42001
#+end_src


To make this directory a Git repository, change to it (using the =cd=
command) and run

#+begin_src shell :results output :exports both
  git init
#+end_src

#+RESULTS:
: Reinitialized existing Git repository in /mnt/shared/scratch/repos/git-intro/0-tracking-changes/.git/

* Making the initial commit

Let's work on a simple python script that reads, plot and fit CSV
data. We start by reading some example data:

The output of =git status= displays information about the state of your
project. If we try it we see that Git has nothing to report on.

#+begin_src shell :results output :exports both
  git status
#+end_src

#+RESULTS:
: On branch main
: Untracked files:
:   (use "git add <file>..." to include in what will be committed)
: 	plot_data.py.orig
: 	plot_data.py.rej
:
: nothing added to commit but untracked files present (use "git add" to track)

Let's do as we are told and run

#+begin_src shell :results output :exports both
  git add plot_data.py example_data.csv
#+end_src

#+RESULTS:

You can now record the state of our file, /i.e./ take your first
snapshot.

#+begin_src shell :exports code
  git commit
#+end_src

#+begin_src shell :results output :exports results
  git commit -m "Add Python script"
#+end_src

#+RESULTS:

* Displaying changes

Let's plot our data using matplotlib

#+begin_src diff :results output :exports code
  diff --git a/plot_data.py b/plot_data.py
  index 6027a65..d5affde 100644
  --- a/plot_data.py
  +++ b/plot_data.py
  @@ -1,3 +1,5 @@
   import numpy
  +import matplotlib.pyplot as plt

   data = numpy.loadtxt("example_data.csv", delimiter=",")
  +plt.plot(data[:, 0], data[:, 1])
#+end_src

#+RESULTS:
: patching file plot_data.py

Check the status of your repository with =git status=

#+begin_src shell :results output :exports both
  git status
#+end_src

#+RESULTS:
: On branch main
: Changes not staged for commit:
:   (use "git add <file>..." to update what will be committed)
:   (use "git restore <file>..." to discard changes in working directory)
: 	modified:   plot_data.py
:
: no changes added to commit (use "git add" and/or "git commit -a")

The above tells us that we modified ~plot_data.py~ since the last
recorded snapshot. We can ask git to print what changed since

#+begin_src shell :results output :exports both
  git diff
#+end_src

#+RESULTS:
#+begin_example
diff --git a/plot_data.py b/plot_data.py
index 150a31c..4dea0d2 100644
--- a/plot_data.py
+++ b/plot_data.py
@@ -1,3 +1,5 @@
 import numpy
+import matplotlib.pyplot as plt

 data = numpy.loadtxt("example_data.csv", delimiter=",")
+plt.plot(data[:, 0], data[:, 1])
#+end_example

* The staging area

Let's make two changes.

First, add a comment describing the two columns in the data file
=example_data.csv=:

#+begin_src diff :exports code
  diff --git a/example_data.csv b/example_data.csv
  index b17ee9d..8ab8126 100644
  --- a/example_data.csv
  +++ b/example_data.csv
  @@ -1,3 +1,4 @@
  +# xdata,ydata
   -2,0.699369
   -1.64,0.700462
   -1.33,0.695354
#+end_src

#+RESULTS:
: patching file example_data.csv

Second, modify the python script =plot_data.py= to add a title to the
figure:

#+begin_src diff :exports code
  diff --git a/plot_data.py b/plot_data.py
  index b4ac3ee..115d618 100644
  --- a/plot_data.py
  +++ b/plot_data.py
  @@ -3,3 +3,4 @@ import matplotlib.pyplot as plt

   data = numpy.loadtxt("example_data.csv", delimiter=",")
   plt.plot(data[:, 0], data[:, 1])
  +plt.title("A title")
#+end_src

#+RESULTS:
: patching file plot_data.py

Try to record a new version with =git commit=:

#+begin_src shell :exports code
  git commit
#+end_src

#+begin_src shell :results output :exports results
  git status
#+end_src

#+RESULTS:
#+begin_example
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   example_data.csv
	modified:   plot_data.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	plot_data.py.orig
	plot_data.py.rej

no changes added to commit (use "git add" and/or "git commit -a")
#+end_example

This time we don't get our editor and the output is the same that ~git
status~. Notice the last line:

#+begin_example
  no changes added to commit (use "git add" and/or "git commit -a")
#+end_example

Git makes use of the concept of the /staging area/ (otherwise known as
the /index/).  The staging area is an intermediate place between the
working directory and the database of recorded versions. To be
included in the next version, changes must be added to the staging
area first. By default, the staging area is empty: recording a version
with =git commit= doesn't make sense since this this version would be
no different than the previous one. In this case, Git does not add a
new version and instead print the output of =git status=, prompting
you to add changes to staging area.

Let's record a new version that includes the change you made to Python
script (adding a title to the figure), but not the change made to the
data file. Start by adding all changes made to the the Python script
=plot_data.py= to the staging area:

#+begin_src shell :results output :exports both
  git add plot_data.py
#+end_src

#+RESULTS:

Use =git status= to display the status of the repository:

#+begin_src shell :results output :exports both
  git status
#+end_src

#+RESULTS:
#+begin_example
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   plot_data.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   example_data.csv

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	plot_data.py.orig
	plot_data.py.rej

#+end_example

Next, display the current differences with

#+begin_src shell :results output :exports both
  git diff
#+end_src

#+RESULTS:
: diff --git a/example_data.csv b/example_data.csv
: index 7eab533..ad38f59 100644
: --- a/example_data.csv
: +++ b/example_data.csv
: @@ -1,3 +1,4 @@
: +# xdata,ydata
:  -2,0.699369
:  -1.64,0.700462
:  -1.33,0.695354

What does this output tells you about the behavior of =git diff=?

It was stated above that the =git diff= command outputs the
differences between the current working directory and the last
recorded snapshot. This is, in fact, inaccurate. The =git diff=
command outputs the differences between the working directory and the
last recorded snapshot, minus whatever changes are currently added in
the staging area, and therefore ready to be recorded in the next
version. In other words, =git diff= display *the differences between
the working directory and the next recorded version*.

Use =git diff= to display the content of the staging area:

#+begin_src shell :results output :exports both
  git diff --staged
#+end_src

#+RESULTS:
#+begin_example
diff --git a/plot_data.py b/plot_data.py
index 150a31c..85bbb3b 100644
--- a/plot_data.py
+++ b/plot_data.py
@@ -1,3 +1,6 @@
 import numpy
+import matplotlib.pyplot as plt

 data = numpy.loadtxt("example_data.csv", delimiter=",")
+plt.plot(data[:, 0], data[:, 1])
+plt.title("A title")
#+end_example

Finally, record a new version including the changes above:

#+begin_src shell :results output :exports both
  git commit -m "Add a title to the figure"
#+end_src

#+RESULTS:
: [main 8a780ee] Add a title to the figure
:  1 file changed, 3 insertions(+)

Repeat the =git add/commit= procedure to record a new version
including the changes made to the data file =example_data.csv=.

#+begin_src shell :results output :exports both
  git add example_data.csv
  git commit -m "Add header to CSV data file"
#+end_src

* Displaying the log of changes

Git provides a wealth of tools to display and analyse the history of a
project. The main entry point to these functionalities is the =git
log= command.

#+begin_src :results output shell :exports code
  git log
#+end_src

#+begin_src :results output shell :exports results
  git log -n 3
#+end_src

You go up and down the list by using the up and down arrow keys on
your keyboard. You can also use the space key to scroll throught one
page at a time. *To exit, press the =q= key*.

The =git log= command prints a list of all our versions
back to the first recorded one (known as the /root commit/). By
default, =git log= includes:

- Author and date.
- Commit message.
- Unique identifier.

Ask Git to print the changes associated to each commit:

#+begin_src shell :exports code
  git log --patch # (or -p)
#+end_src

#+begin_src shell :results output :exports results
  git log -p -3
#+end_src

* Git is line-oriented

Let's introduce a temporary variable to avoid hardcoing the name of
our data file in the call to ~loadtxt~.

#+begin_src diff :exports code
  diff --git a/plot_data.py b/plot_data.py
  index d5affde..1c37f09 100644
  --- a/plot_data.py
  +++ b/plot_data.py
  @@ -1,5 +1,6 @@
   import numpy
   import matplotlib.pyplot as plt

  -data = np.loadtxt("example_data.csv", delimiter=",")
  +filename = "example_data.csv"
  +data = np.loadtxt(filename, delimiter=",")
   plt.plot(data[:, 0], data[:, 1])
#+end_src

Use =git diff= to visualise your changes:

#+begin_src shell :results output :exports both
  git diff
#+end_src

Alternatively, you can use the =--stat= option to display the number
of lines added and removed -- among other things.

#+begin_src shell :results output :exports both
  git diff --stat
#+end_src

Git counts two one line removed, and two lines added. Even though you
changes only part of a line, Git considers that the whole line
changed, replace by another one.

*Lesson: for Git, the smallest unit of change is the line.*
